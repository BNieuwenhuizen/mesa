/*
 * Copyright Â© 2023 Bas Nieuwenhuizen
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#include "radv_nir.h"
#include "nir_builder.h"

static unsigned
radv_nir_coop_matrix_length(struct glsl_cooperative_matrix_description desc, unsigned wave_size)
{
   return desc.use != GLSL_COOPERATIVE_MATRIX_USE_ACCUMULATOR ? 16 : ((wave_size == 64 ? 4 : 8) * 32 / glsl_base_type_bit_size(desc.element_type));
}

/* for C matrices we have 1 VGPR per element even if the element type is < 32 bits. So with 8 fp16 elements we implement that with a f16vec16. We then
 * use the coefficient generated by this function to figure out how many elements we really have.
 */
static unsigned
radv_nir_coop_matrix_length_mul(struct glsl_cooperative_matrix_description desc)
{
   return desc.use == GLSL_COOPERATIVE_MATRIX_USE_ACCUMULATOR ? (32 / glsl_base_type_bit_size(desc.element_type)) : 1;
}

static unsigned radv_nir_coop_matrix_bits(struct glsl_cooperative_matrix_description desc)
{
   return glsl_base_type_bit_size(desc.element_type);
}

static bool
radv_nir_fix_coop_matrix_insn_type(nir_instr *instr, nir_function_impl *impl, unsigned wave_size, bool changed_src)
{
   nir_def *def = nir_instr_ssa_def(instr);
   int old_comp = 0, old_bits = 0;
   if (def) {
      old_comp = def->num_components;
      old_bits = def->bit_size;
   }

   switch (instr->type) {
   case nir_instr_type_intrinsic: {
      nir_intrinsic_instr *intr = nir_instr_as_intrinsic(instr);
      switch(intr->intrinsic) {
      case nir_intrinsic_coop_construct:
      case nir_intrinsic_coop_load: {
         struct glsl_cooperative_matrix_description desc = nir_intrinsic_matrix_desc(intr);
         def->num_components = radv_nir_coop_matrix_length(desc, wave_size);
         def->bit_size = radv_nir_coop_matrix_bits(desc);
         break;
      }
      case nir_intrinsic_coop_unary_op:
      case nir_intrinsic_coop_binary_op:
      case nir_intrinsic_coop_scalar_op:
      case nir_intrinsic_coop_bitcast:
         def->num_components = intr->src[0].ssa->num_components;
         def->bit_size = intr->src[0].ssa->bit_size;
         break;
      case nir_intrinsic_coop_insert:
         def->num_components = intr->src[1].ssa->num_components;
         def->bit_size = intr->src[1].ssa->bit_size;
         break;
      case nir_intrinsic_coop_muladd:
         def->num_components = intr->src[2].ssa->num_components;
         def->bit_size = intr->src[2].ssa->bit_size;
         break;
      case nir_intrinsic_load_deref: {
         nir_deref_instr *deref = nir_src_as_deref(intr->src[0]);
         if (!glsl_type_is_cooperative_matrix(deref->type))
            return false;

         struct glsl_cooperative_matrix_description desc = *glsl_get_cooperative_matrix_description(deref->type);
         intr->num_components = def->num_components = radv_nir_coop_matrix_length(desc, wave_size);
         def->bit_size = radv_nir_coop_matrix_bits(desc);

         break;
      }
      case nir_intrinsic_store_deref: {
         nir_deref_instr *deref = nir_src_as_deref(intr->src[0]);
         if (!glsl_type_is_cooperative_matrix(deref->type))
            return false;

         struct glsl_cooperative_matrix_description desc = *glsl_get_cooperative_matrix_description(deref->type);
         nir_intrinsic_set_write_mask(intr, (1u << radv_nir_coop_matrix_length(desc, wave_size)) - 1);
         intr->num_components = radv_nir_coop_matrix_length(desc, wave_size);
         return true;
      }
      default:
         return false;
      }
      break;
   }
   case nir_instr_type_alu: {
      if (!changed_src)
         return false;

      nir_alu_instr *alu = nir_instr_as_alu(instr);
      assert(alu->op == nir_op_mov);
      def->num_components = alu->src[0].src.ssa->num_components;
      def->bit_size = alu->src[0].src.ssa->bit_size;
      break;
   }
   case nir_instr_type_phi: {
      if (!changed_src)
         return false;

      nir_phi_instr *phi = nir_instr_as_phi(instr);
      nir_foreach_phi_src(src, phi) {
          if (src->src.ssa->num_components > def->num_components) {
             def->num_components = src->src.ssa->num_components;
             def->bit_size = src->src.ssa->bit_size;
          }
      }
      nir_foreach_phi_src (src, phi) {
          if (src->src.ssa->num_components < def->num_components && src->src.ssa->parent_instr &&
              src->src.ssa->parent_instr->type == nir_instr_type_ssa_undef) {
             /* Undef is never going to get changed otherwise so we need to change it here. Create a new one as undefs
              * may be shared. */
             nir_builder b = nir_builder_create(impl);
             b.cursor = nir_before_instr(src->src.ssa->parent_instr);

             nir_def *undef = nir_undef(&b, def->num_components, def->bit_size);
             nir_src_rewrite(&src->src, undef);
          }
      }
    break;
   }
   default:
      return false;
   }

   if (def && (old_comp != def->num_components || old_bits != def->bit_size)) {
      nir_foreach_use(src, def) {
          radv_nir_fix_coop_matrix_insn_type(src->parent_instr, impl, wave_size, true);
      }

      return true;
   }

   return false;
}

static bool
radv_nir_fix_coop_matrix_types(nir_shader *shader, unsigned wave_size)
{
   bool progress = false;

   struct nir_function *func = (struct nir_function *)exec_list_get_head_const(&shader->functions);
   nir_foreach_block (block, func->impl) {
      nir_foreach_instr_safe (instr, block) {
          if (radv_nir_fix_coop_matrix_insn_type(instr, func->impl, wave_size, false))
             progress = true;
      }
   }
   return progress;
}

static const struct glsl_type *
radv_nir_translate_matrix_type(const struct glsl_type *orig_type, struct hash_table *type_map, unsigned wave_size)
{
   if (glsl_type_is_cooperative_matrix(orig_type)) {
      struct glsl_cooperative_matrix_description desc = *glsl_get_cooperative_matrix_description(orig_type);
      unsigned length = radv_nir_coop_matrix_length(desc, wave_size);

      return glsl_vector_type(desc.element_type, length);
   } else if (glsl_type_is_array(orig_type)) {
      const struct glsl_type *elem_type = glsl_get_array_element(orig_type);
      const struct glsl_type *new_elem_type = radv_nir_translate_matrix_type(elem_type, type_map, wave_size);

      if (elem_type == new_elem_type)
         return orig_type;

      return glsl_array_type(new_elem_type, glsl_get_length(orig_type), glsl_get_explicit_stride(orig_type));
   } else if (glsl_type_is_struct(orig_type)) {
      unsigned num_fields = glsl_get_length(orig_type);

      bool change = true;
      for (unsigned i = 0; i < num_fields; ++i) {
         const struct glsl_type *field_type = glsl_get_struct_field(orig_type, i);
         const struct glsl_type *new_field_type = radv_nir_translate_matrix_type(field_type, type_map, wave_size);

         if (field_type != new_field_type) {
            change = true;
            break;
         }
      }

      if (!change)
         return orig_type;

      struct glsl_struct_field *fields = malloc(sizeof(struct glsl_struct_field) * num_fields);

      for (unsigned i = 0; i < num_fields; ++i) {
         fields[i] = *glsl_get_struct_field_data(orig_type, i);

         fields[i].type = radv_nir_translate_matrix_type(fields[i].type, type_map, wave_size);
      }

      const struct glsl_type *ret = glsl_struct_type(fields, num_fields, glsl_get_type_name(orig_type), glsl_struct_type_is_packed(orig_type));
      free(fields);
      return ret;
   } else
      return orig_type;
}

bool
radv_nir_lower_cooperative_matrix(nir_shader *shader, unsigned wave_size)
{
   bool progress = radv_nir_fix_coop_matrix_types(shader, wave_size);

   struct nir_function *func = (struct nir_function *)exec_list_get_head_const(&shader->functions);

   nir_foreach_variable_with_modes(var, shader, nir_var_shader_temp) {
      const struct glsl_type *new_type = radv_nir_translate_matrix_type(var->type, NULL, wave_size);
      if (new_type != var->type) {
         var->type = new_type;
         progress = true;
      }
   }

   nir_foreach_function_temp_variable(var, func->impl) {
      const struct glsl_type *new_type = radv_nir_translate_matrix_type(var->type, NULL, wave_size);
      if (new_type != var->type) {
         var->type = new_type;
         progress = true;
      }
   }

   nir_builder b = nir_builder_create(func->impl);
   nir_foreach_block (block, func->impl) {
      nir_foreach_instr_safe (instr, block) {
         b.cursor = nir_before_instr(instr);

         switch(instr->type) {
         case nir_instr_type_intrinsic: {
            nir_intrinsic_instr *intr = nir_instr_as_intrinsic(instr);
            switch (intr->intrinsic) {
            case nir_intrinsic_coop_length: {
               struct glsl_cooperative_matrix_description desc = nir_intrinsic_matrix_desc(intr);
               unsigned len = radv_nir_coop_matrix_length(desc, wave_size) / radv_nir_coop_matrix_length_mul(desc);
               nir_def_rewrite_uses(&intr->def, nir_imm_int(&b, len));
               nir_instr_remove(instr);
               progress = true;
               break;
            }
            case nir_intrinsic_coop_bitcast: {
               nir_def *src = intr->src[0].ssa;
               nir_def_rewrite_uses(&intr->def, src);
               nir_instr_remove(instr);
               progress = true;
               break;
            }
            case nir_intrinsic_coop_extract: {
               struct glsl_cooperative_matrix_description desc = nir_intrinsic_matrix_desc(intr);
               nir_def *index = intr->src[1].ssa;
               index = nir_imul_imm(&b, index, radv_nir_coop_matrix_length_mul(desc));

               nir_def *elem = nir_vector_extract(&b, intr->src[0].ssa, index);
               
               nir_def_rewrite_uses(&intr->def, elem);
               nir_instr_remove(instr);
               progress = true;
               break;
            }
            case nir_intrinsic_coop_insert: {
               struct glsl_cooperative_matrix_description desc = nir_intrinsic_matrix_desc(intr);
               nir_def *index = intr->src[2].ssa;
               index = nir_imul_imm(&b, index, radv_nir_coop_matrix_length_mul(desc));
            
               nir_def *elem = intr->src[0].ssa;
               nir_def *r = nir_vector_insert(&b, intr->src[1].ssa, elem, index);
               nir_def_rewrite_uses(&intr->def, r);
               nir_instr_remove(instr);
               progress = true;
               break;
            }
            case nir_intrinsic_coop_construct: {
               struct glsl_cooperative_matrix_description desc = nir_intrinsic_matrix_desc(intr);
               nir_def *elem = intr->src[0].ssa;

               nir_def *r = nir_replicate(&b, elem, radv_nir_coop_matrix_length(desc, wave_size));
               nir_def_rewrite_uses(&intr->def, r);
               nir_instr_remove(instr);
               progress = true;
               break;
            }
            case nir_intrinsic_coop_load: {
               struct glsl_cooperative_matrix_description desc = nir_intrinsic_matrix_desc(intr);
               enum glsl_matrix_layout layout = nir_intrinsic_matrix_layout(intr);

               nir_deref_instr *deref = nir_instr_as_deref(intr->src[0].ssa->parent_instr);
               nir_def *stride = intr->src[1].ssa;

               nir_def *local_idx = nir_load_subgroup_invocation(&b);
               nir_def *inner_idx = nir_iand_imm(&b, local_idx, 15);

               /* A input is transposed */
               if (desc.use == GLSL_COOPERATIVE_MATRIX_USE_A)
                  layout = layout == GLSL_MATRIX_LAYOUT_COLUMN_MAJOR ? GLSL_MATRIX_LAYOUT_ROW_MAJOR : GLSL_MATRIX_LAYOUT_COLUMN_MAJOR;

               unsigned length = radv_nir_coop_matrix_length(desc, wave_size);
               unsigned mul = radv_nir_coop_matrix_length_mul(desc);
               unsigned lanes_per_iter = desc.use == GLSL_COOPERATIVE_MATRIX_USE_ACCUMULATOR ? wave_size : 16;
               nir_def *vars[16];
               if (mul > 1) {
                  for (unsigned i = 0; i < length; ++i)
                     if (i % mul != 0)
                        vars[i] = nir_undef(&b, 1, intr->def.bit_size);
               }

               unsigned idx_bits = deref->def.bit_size;
               nir_def *base_row = desc.use == GLSL_COOPERATIVE_MATRIX_USE_ACCUMULATOR
                                          ? nir_udiv_imm(&b, local_idx, 16)
                                          : nir_imm_int(&b, 0);

               for (unsigned i = 0; i < length / mul; ++i) {
                  nir_def *col_offset = inner_idx;
                  nir_def *row_offset = nir_iadd_imm(&b, base_row, i * lanes_per_iter / 16);

                  if (layout == GLSL_MATRIX_LAYOUT_ROW_MAJOR) {
                     nir_def *tmp = col_offset;
                     col_offset = row_offset;
                     row_offset = tmp;
                  }

                  col_offset = nir_imul(&b, col_offset, stride);

                  col_offset = nir_u2uN(&b, col_offset, idx_bits);
                  row_offset = nir_u2uN(&b, row_offset, idx_bits);

                  nir_deref_instr *iter_deref = nir_build_deref_ptr_as_array(&b, deref, col_offset);
                  iter_deref =
                     nir_build_deref_cast(&b, &iter_deref->def, deref->modes, glsl_scalar_type(desc.element_type),
                                          glsl_base_type_bit_size(desc.element_type) / 8);
                  iter_deref = nir_build_deref_ptr_as_array(&b, iter_deref, row_offset);

                  vars[i * mul] = nir_load_deref(&b, iter_deref);
               }

               nir_def *mat = nir_vec(&b, vars, length);
               nir_def_rewrite_uses(&intr->def, mat);
               nir_instr_remove(instr);
               progress = true;
               break;
            }
            case nir_intrinsic_coop_store: {
               struct glsl_cooperative_matrix_description desc = nir_intrinsic_matrix_desc(intr);
               enum glsl_matrix_layout layout = nir_intrinsic_matrix_layout(intr);

               nir_deref_instr *deref = nir_instr_as_deref(intr->src[0].ssa->parent_instr);
               nir_def *src = intr->src[1].ssa;
               nir_def *stride = intr->src[2].ssa;

               nir_def *local_idx = nir_load_subgroup_invocation(&b);

               if (desc.use != GLSL_COOPERATIVE_MATRIX_USE_ACCUMULATOR)
                  nir_push_if(&b, nir_ilt_imm(&b, local_idx, 16));
               
               nir_def *inner_idx = nir_iand_imm(&b, local_idx, 15);

               /* A input is transposed */
               if (desc.use == GLSL_COOPERATIVE_MATRIX_USE_A)
                  layout = layout == GLSL_MATRIX_LAYOUT_COLUMN_MAJOR ? GLSL_MATRIX_LAYOUT_ROW_MAJOR : GLSL_MATRIX_LAYOUT_COLUMN_MAJOR;

               unsigned length = radv_nir_coop_matrix_length(desc, wave_size);
               unsigned mul = radv_nir_coop_matrix_length_mul(desc);
               unsigned lanes_per_iter = desc.use == GLSL_COOPERATIVE_MATRIX_USE_ACCUMULATOR ? wave_size : 16;
               nir_def *vars[16];
               for (unsigned i = 0; i < length; ++i)
                  vars[i] = nir_channel(&b, src, i);

               unsigned idx_bits = deref->def.bit_size;
               nir_def *base_row = desc.use == GLSL_COOPERATIVE_MATRIX_USE_ACCUMULATOR
                                          ? nir_udiv_imm(&b, local_idx, 16)
                                          : nir_imm_int(&b, 0);

               for (unsigned i = 0; i < length / mul; ++i) {
                  nir_def *col_offset = inner_idx;
                  nir_def *row_offset = nir_iadd_imm(&b, base_row, i * lanes_per_iter / 16);

                  if (layout == GLSL_MATRIX_LAYOUT_ROW_MAJOR) {
                     nir_def *tmp = col_offset;
                     col_offset = row_offset;
                     row_offset = tmp;
                  }

                  col_offset = nir_imul(&b, col_offset, stride);

                  col_offset = nir_u2uN(&b, col_offset, idx_bits);
                  row_offset = nir_u2uN(&b, row_offset, idx_bits);

                  nir_deref_instr *iter_deref = nir_build_deref_ptr_as_array(&b, deref, col_offset);
                  iter_deref =
                     nir_build_deref_cast(&b, &iter_deref->def, deref->modes, glsl_scalar_type(desc.element_type),
                                          glsl_base_type_bit_size(desc.element_type) / 8);
                  iter_deref = nir_build_deref_ptr_as_array(&b, iter_deref, row_offset);

                  nir_store_deref(&b, iter_deref, vars[i * mul], 1);
               }

               if (desc.use != GLSL_COOPERATIVE_MATRIX_USE_ACCUMULATOR)
                  nir_pop_if(&b, NULL);

               nir_instr_remove(instr);
               progress = true;
               break;
            }
            case nir_intrinsic_coop_muladd: {
               nir_def *A = intr->src[0].ssa;
               nir_def *B = intr->src[1].ssa;
               nir_def *C = intr->src[2].ssa;
               nir_def *ret;

               ret = nir_coop_muladd_amd(&b, A, B, C, .saturate = nir_intrinsic_saturate(intr),
                                         .matrix_signed_mask = nir_intrinsic_matrix_signed_mask(intr));
               nir_def_rewrite_uses(&intr->def, ret);
               nir_instr_remove(instr);
               progress = true;
               break;
            }
            case nir_intrinsic_coop_unary_op: {
               struct glsl_cooperative_matrix_description desc = nir_intrinsic_matrix_desc(intr);
               nir_def *src = intr->src[0].ssa;
               nir_op op = nir_intrinsic_alu_op(intr);

               if ((op == nir_op_f2f32 || op == nir_op_i2i32 || op == nir_op_u2u32 || op == nir_op_f2i32 ||
                    op == nir_op_f2u32 || op == nir_op_i2f32 || op == nir_op_u2f32) &&
                   intr->src[0].ssa->bit_size == 16 && desc.use == GLSL_COOPERATIVE_MATRIX_USE_ACCUMULATOR) {
                  nir_def *components[NIR_MAX_VEC_COMPONENTS];
                  for (unsigned i = 0; i * 2 < src->num_components; ++i) {
                     components[i] = nir_channel(&b, src, i * 2);
                  }
                  src = nir_vec(&b, components, src->num_components / 2);
               }

               nir_def *ret = nir_build_alu1(&b, op, src);

               if ((op == nir_op_f2f16 || op == nir_op_i2i16 || op == nir_op_u2u16 || op == nir_op_f2u16 ||
                    op == nir_op_f2i16 || op == nir_op_i2f16 || op == nir_op_u2f16) &&
                   intr->src[0].ssa->bit_size == 32 && desc.use == GLSL_COOPERATIVE_MATRIX_USE_ACCUMULATOR) {
                  nir_def *components[NIR_MAX_VEC_COMPONENTS];
                  for (unsigned i = 0; i < ret->num_components; ++i) {
                     components[i * 2] = nir_channel(&b, ret, i);
                     components[i * 2 + 1] = nir_undef(&b, 1, 16);
                  }
                  ret = nir_vec(&b, components, ret->num_components * 2);
               }

               nir_def_rewrite_uses(&intr->def, ret);
               nir_instr_remove(instr);
               progress = true;
               break;
            }
            case nir_intrinsic_coop_scalar_op:
            case nir_intrinsic_coop_binary_op: {
               nir_op op = nir_intrinsic_alu_op(intr);
               nir_def *ret = nir_build_alu2(&b, op, intr->src[0].ssa, intr->src[1].ssa);
               nir_def_rewrite_uses(&intr->def, ret);
               nir_instr_remove(instr);
               progress = true;
               break;
            }
            default:
               continue;
            }
            break;
         }
         case nir_instr_type_deref: {
            nir_deref_instr *deref = nir_instr_as_deref(instr);
            const struct glsl_type *new_type = radv_nir_translate_matrix_type(deref->type, NULL, wave_size);
            if (new_type != deref->type) {
               deref->type = new_type;
               progress = true;
            }
            break;
         }
         default:
            continue;
         }
      }
   }

   if (progress) {
      nir_metadata_preserve(func->impl, 0);
   } else {
      nir_metadata_preserve(func->impl, nir_metadata_all);
   }

   return progress;
}
